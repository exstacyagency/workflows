import { NextRequest, NextResponse } from "next/server";
import { JobStatus, JobType, Prisma } from "@prisma/client";
import { prisma } from "@/lib/prisma";
import { getSessionUserId } from "@/lib/getSessionUserId";
import { requireProjectOwner404 } from "@/lib/auth/requireProjectOwner404";
import { ensureProductTableColumns, findOwnedProductById } from "@/lib/productStore";
import { sanitizeCharacterDescription } from "@/lib/sanitizeCharacterDescription";
import { POST as startVideoImagesStartPost } from "./start/route";

type StoryboardJobRow = {
  id: string;
  payload: unknown;
  resultSummary: unknown;
};

function asObject(value: unknown): Record<string, unknown> | null {
  return value && typeof value === "object" && !Array.isArray(value)
    ? (value as Record<string, unknown>)
    : null;
}

function asString(value: unknown): string {
  if (typeof value !== "string") return "";
  return value.trim();
}

function isS3Url(value: string | null | undefined): boolean {
  const url = String(value ?? "").trim();
  if (!url) return false;
  return /^https?:\/\/[^/]*s3[^/]*amazonaws\.com\/.+/i.test(url);
}

/**
 * Returns true if the string looks like it was generated by the avatar/character-reference
 * generation flow rather than a scene-safe visual description.
 *
 * Avatar-template prompts contain phrases like:
 *   "Full-body character reference image. Plain white or transparent background..."
 * These must never be injected into first-frame scene prompts because they cause the image
 * model to output avatar-style white-background reference sheets instead of UGC scene stills.
 */
const AVATAR_TEMPLATE_MARKERS = [
  "full-body character reference image",
  "plain white or transparent background",
  "character reference image",
  "transparent background",
];

function isAvatarTemplatePrompt(text: string | null | undefined): boolean {
  if (!text) return false;
  const lower = text.toLowerCase();
  return AVATAR_TEMPLATE_MARKERS.some((marker) => lower.includes(marker));
}

function extractSceneFrameUrls(rawValue: unknown): {
  firstFrameImageUrl: string | null;
  lastFrameImageUrl: string | null;
} {
  const raw = asObject(rawValue) ?? {};
  const firstFromRaw =
    asString(raw.firstFrameImageUrl) ||
    asString(raw.firstFrameUrl) ||
    asString(raw.first_frame_url);
  const lastFromRaw =
    asString(raw.lastFrameImageUrl) ||
    asString(raw.lastFrameUrl) ||
    asString(raw.last_frame_url);

  let firstFrameImageUrl = firstFromRaw || null;
  let lastFrameImageUrl = lastFromRaw || null;

  const images = Array.isArray(raw.images)
    ? raw.images
    : Array.isArray((asObject(raw.polled) ?? {}).images)
      ? ((asObject(raw.polled) ?? {}).images as unknown[])
      : [];

  for (const image of images) {
    const imageObj = asObject(image) ?? {};
    const imageUrl = asString(imageObj.url);
    if (!imageUrl) continue;
    const kind = asString(imageObj.promptKind || imageObj.frameType).toLowerCase();
    if (kind === "last") {
      lastFrameImageUrl = lastFrameImageUrl || imageUrl;
    } else {
      firstFrameImageUrl = firstFrameImageUrl || imageUrl;
    }
  }

  if (!lastFrameImageUrl && firstFrameImageUrl) {
    lastFrameImageUrl = firstFrameImageUrl;
  }

  return {
    firstFrameImageUrl,
    lastFrameImageUrl,
  };
}

function getStoryboardIdFromCompletedJob(job: StoryboardJobRow | null): string | null {
  if (!job) return null;

  const payload = asObject(job.payload) ?? {};
  const payloadResult = asObject(payload.result);
  const fromPayloadResult = asString(payloadResult?.storyboardId);
  if (fromPayloadResult) return fromPayloadResult;

  const fromPayload = asString(payload.storyboardId);
  if (fromPayload) return fromPayload;

  const summary = job.resultSummary;
  if (summary && typeof summary === "object") {
    const summaryObj = summary as Record<string, unknown>;
    const fromSummary = asString(summaryObj.storyboardId);
    if (fromSummary) return fromSummary;
    const nestedSummary = asObject(summaryObj.summary);
    const fromNestedSummary = asString(nestedSummary?.storyboardId);
    if (fromNestedSummary) return fromNestedSummary;
  }

  if (typeof summary === "string" && summary.trim()) {
    const match = summary.match(/storyboardId=([^) ,]+)/);
    if (match?.[1]) return match[1];
  }

  return null;
}

function buildFirstFramePrompt(args: {
  sceneNumber: number;
  panelType: string;
  beatLabel: string;
  vo: string;
  characterAction: string;
  cameraDirection: string;
  environment: string;
  productPlacement: string;
  bRollSuggestions: string[];
  characterName: string;
  characterDescription: string;
  previousSceneLastFrameImageUrl: string | null;
}): string {
  const {
    sceneNumber,
    panelType,
    beatLabel,
    vo,
    characterAction,
    cameraDirection,
    environment,
    productPlacement,
    bRollSuggestions,
    characterName,
    characterDescription,
    previousSceneLastFrameImageUrl,
  } = args;
  const broll = bRollSuggestions.filter(Boolean).join(" | ");
  const environmentLock =
    panelType !== "ON_CAMERA" && environment
      ? `ENVIRONMENT LOCK (B-roll/hands shot): This shot is in the SAME ROOM as the creator scenes. Desk color, desk surface, wall color, lamp style, and all room props must EXACTLY match the creator scenes. Do NOT introduce a new desk or table surface. Room: ${environment}`
      : null;
  const creatorPresent =
    panelType === "ON_CAMERA"
      ? "Creator is visible and speaking to camera."
      : "B-roll scene: creator voiceover is present but creator is NOT shown.";

  const continuityLine = previousSceneLastFrameImageUrl
    ? "CONTINUITY: Three reference images are provided. The FIRST is the previous scene — match exactly: same desk color and surface material, same wall color, same room props, same lamp style and position, same window darkness/brightness, same creator face and build. CRITICAL: Do NOT change desk color or surface between scenes. The SECOND is the creator avatar — match face, wardrobe, and hair exactly throughout. The THIRD is the product reference — match packaging, label text, colors, and container shape exactly."
    : "CONTINUITY: Two reference images are provided. The FIRST is the creator avatar — match face, build, eyes, and hair exactly. The SECOND is the product reference — match packaging, label text, colors, and container shape exactly.";

  return [
    "STYLE: Authentic smartphone UGC. Raw image content only — NO UI chrome, NO app interface, NO status bar, NO Instagram/TikTok frame, NO social media overlay, NO profile header, NO message bar, NO screen recording frame. Just the image itself. NOT cinematic. NOT a production still. NOT commercial photography.",
    continuityLine,
    `UGC ad first-frame still for Scene ${sceneNumber}${beatLabel ? ` (${beatLabel})` : ""}.`,
    creatorPresent,
    environmentLock,
    `Character name: ${characterName}`,
    `Character description: ${characterDescription}`,
    vo ? `VO context: ${vo}` : "",
    characterAction ? `Character action: ${characterAction}` : "",
    cameraDirection ? `Camera direction: ${cameraDirection}` : "",
    environment ? `Environment: ${environment}` : "",
    productPlacement ? `Product placement: ${productPlacement}` : "",
    broll ? `Text overlays / b-roll intent: ${broll}` : "",
    "Realism: ultra-realistic.",
    "Detail level: high skin and fabric texture detail.",
    "Natural skin imperfections: pores, subtle texture visible.",
    "Shot on iPhone, slightly imperfect framing.",
    "Available light only.",
    "Negative prompt: no blurry image, no glossy skin, no overexposed highlights, no flat lighting, no plastic skin texture, no symmetrical lighting, no HDR effect, no airbrushed skin, no UI chrome, no app interface overlays.",
    "Render as smartphone-shot UGC (not commercial): natural lighting, real room, handheld realism, vertical 9:16. Output is the raw photo frame only — no phone UI, no app chrome, no overlaid interface elements.",
  ]
    .filter(Boolean)
    .join("\n");
}

export async function POST(req: NextRequest) {
  const userId = await getSessionUserId();
  if (!userId) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  let body: Record<string, unknown>;
  try {
    const raw = await req.json();
    body = asObject(raw) ?? {};
  } catch {
    return NextResponse.json({ error: "Invalid JSON body" }, { status: 400 });
  }

  const runId = asString(body.runId);
  const characterId = asString(body.characterId);
  const projectId = asString(body.projectId);
  const productId = asString(body.productId);

  if (!projectId) {
    return NextResponse.json({ error: "Missing projectId" }, { status: 400 });
  }
  if (!productId) {
    return NextResponse.json({ error: "Missing productId" }, { status: 400 });
  }

  const hasRequestedSceneNumber =
    body.sceneNumber !== undefined && body.sceneNumber !== null && String(body.sceneNumber).trim() !== "";
  const requestedSceneNumberRaw = hasRequestedSceneNumber ? Number(body.sceneNumber) : Number.NaN;
  if (
    hasRequestedSceneNumber &&
    (!Number.isFinite(requestedSceneNumberRaw) ||
      !Number.isInteger(requestedSceneNumberRaw) ||
      requestedSceneNumberRaw < 1)
  ) {
    return NextResponse.json({ error: "sceneNumber must be a positive integer when provided." }, { status: 400 });
  }
  const requestedSceneNumber = hasRequestedSceneNumber ? Math.trunc(requestedSceneNumberRaw) : null;
  const additionalInstructions = asString(body.additionalInstructions);

  const deny = await requireProjectOwner404(projectId);
  if (deny) return deny;
  await ensureProductTableColumns();

  const ownedProduct = await findOwnedProductById(productId, userId);
  if (!ownedProduct || ownedProduct.projectId !== projectId) {
    return NextResponse.json({ error: "Product not found for this project." }, { status: 404 });
  }

  const productReferenceImageUrl = asString(ownedProduct.productReferenceImageUrl);
  if (!productReferenceImageUrl) {
    return NextResponse.json(
      {
        error:
          "First-frame generation requires a product reference image. Upload product image in Product Setup first.",
      },
      { status: 409 },
    );
  }

  const requestedStoryboardId = asString(body.storyboardId);
  let storyboardId: string | null = requestedStoryboardId || null;
  if (!storyboardId) {
    const latestCompletedStoryboardJob = await prisma.job.findFirst({
      where: {
        userId,
        projectId,
        type: JobType.STORYBOARD_GENERATION,
        status: JobStatus.COMPLETED,
      },
      orderBy: [{ updatedAt: "desc" }, { createdAt: "desc" }],
      select: {
        id: true,
        payload: true,
        resultSummary: true,
      },
    });
    storyboardId = getStoryboardIdFromCompletedJob(latestCompletedStoryboardJob);
  }
  if (!storyboardId) {
    return NextResponse.json(
      { error: "No completed storyboard found for this project. Run Create Storyboard first." },
      { status: 409 },
    );
  }

  const storyboard = await prisma.storyboard.findFirst({
    where: {
      id: storyboardId,
      projectId,
    },
    select: {
      id: true,
      scenes: {
        orderBy: { sceneNumber: "asc" },
        select: {
          id: true,
          sceneNumber: true,
          rawJson: true,
        },
      },
    },
  });

  if (!storyboard) {
    return NextResponse.json({ error: "Latest completed storyboard no longer exists." }, { status: 404 });
  }

  if (!storyboard.scenes.length) {
    return NextResponse.json({ error: "Storyboard has no scenes. Regenerate storyboard first." }, { status: 409 });
  }

  const requestedCharacter = characterId
    ? await prisma.character.findFirst({
        where: {
          id: characterId,
          projectId,
        },
        select: {
          id: true,
          runId: true,
          productId: true,
          name: true,
          creatorVisualPrompt: true,
          seedVideoUrl: true,
        },
      })
    : null;
  if (characterId && !requestedCharacter) {
    return NextResponse.json({ error: "characterId not found for this project." }, { status: 400 });
  }
  if (runId && requestedCharacter && String(requestedCharacter.runId ?? "") !== runId) {
    return NextResponse.json({ error: "characterId does not belong to selected run." }, { status: 400 });
  }
  if (requestedCharacter && String(requestedCharacter.productId ?? "") !== productId) {
    return NextResponse.json({ error: "characterId does not belong to selected product." }, { status: 400 });
  }

  const firstSceneRaw = asObject(storyboard.scenes[0]?.rawJson) ?? {};
  const resolvedCharacterName = asString(requestedCharacter?.name) || asString(firstSceneRaw.characterName);

  // Defensively filter out avatar-template prompts from creatorVisualPrompt.
  // If the character was generated via the avatar flow, creatorVisualPrompt contains
  // phrases like "Full-body character reference image. Plain white or transparent background..."
  // Injecting that text into a scene prompt causes the image model to output avatar-style
  // white-background reference sheets instead of UGC scene stills.
  const rawCreatorVisualPrompt = asString(requestedCharacter?.creatorVisualPrompt);
  const safeCreatorVisualPrompt = isAvatarTemplatePrompt(rawCreatorVisualPrompt)
    ? null
    : rawCreatorVisualPrompt || null;
  const rawSceneCharacterDescription = asString(firstSceneRaw.characterDescription);
  const safeSceneCharacterDescription = sanitizeCharacterDescription(rawSceneCharacterDescription);
  const resolvedCharacterDescription =
    safeCreatorVisualPrompt || safeSceneCharacterDescription;

  const resolvedAvatarImageUrl = [
    asString(ownedProduct.characterAvatarImageUrl),
    asString(ownedProduct.creatorReferenceImageUrl),
    asString(requestedCharacter?.seedVideoUrl),
  ].find((url) => isS3Url(url)) || "";

  if (!resolvedCharacterName || !resolvedCharacterDescription) {
    return NextResponse.json(
      {
        error:
          "Missing selected character context. Ensure character has name + description and regenerate storyboard if needed.",
      },
      { status: 409 },
    );
  }

  if (!resolvedAvatarImageUrl) {
    return NextResponse.json(
      {
        error:
          "Missing selected avatar image on S3. Generate/select a character avatar stored in S3 before generating first frames.",
      },
      { status: 409 },
    );
  }

  const scenesWithContext = storyboard.scenes.map((scene) => {
    const rawJson = asObject(scene.rawJson) ?? {};
    const frameUrls = extractSceneFrameUrls(rawJson);
    return {
      sceneId: asString(scene.id),
      sceneNumber: Number(scene.sceneNumber),
      panelType: asString(rawJson.panelType) || "ON_CAMERA",
      beatLabel: asString(rawJson.beatLabel),
      vo: asString(rawJson.vo),
      characterAction: asString(rawJson.characterAction),
      cameraDirection: asString(rawJson.cameraDirection),
      environment: asString(rawJson.environment),
      productPlacement: asString(rawJson.productPlacement),
      bRollSuggestions: Array.isArray(rawJson.bRollSuggestions)
        ? rawJson.bRollSuggestions.map((entry) => asString(entry)).filter(Boolean)
        : [],
      firstFrameImageUrl: frameUrls.firstFrameImageUrl,
      lastFrameImageUrl: frameUrls.lastFrameImageUrl,
    };
  });

  let targetScenes = scenesWithContext;
  if (requestedSceneNumber !== null) {
    const targetScene = scenesWithContext.find((scene) => scene.sceneNumber === requestedSceneNumber);
    if (!targetScene) {
      return NextResponse.json({ error: `Scene ${requestedSceneNumber} not found in storyboard.` }, { status: 404 });
    }
    targetScenes = [targetScene];
  }

  const scenesByNumber = new Map<number, (typeof scenesWithContext)[number]>();
  for (const scene of scenesWithContext) {
    scenesByNumber.set(scene.sceneNumber, scene);
  }
  const prompts = targetScenes.map((scene) => {
    const isScene1 = scene.sceneNumber === 1;
    const previousScene = scenesByNumber.get(scene.sceneNumber - 1) ?? null;
    const previousSceneFirstFrameImageUrlRaw =
      previousScene?.firstFrameImageUrl || previousScene?.lastFrameImageUrl || null;
    const previousSceneLastFrameImageUrl = isScene1
      ? null
      : isS3Url(previousSceneFirstFrameImageUrlRaw)
        ? previousSceneFirstFrameImageUrlRaw
        : null;
    if (!isScene1 && !previousSceneLastFrameImageUrl) {
      throw new Error(
        `Scene ${scene.sceneNumber} requires previous scene first-frame image on S3 (scene ${scene.sceneNumber - 1}).`,
      );
    }
    const referenceImageUrls = [productReferenceImageUrl].filter(
      (url): url is string => typeof url === "string" && url.length > 0,
    );

    const basePrompt = buildFirstFramePrompt({
      sceneNumber: scene.sceneNumber,
      panelType: scene.panelType,
      beatLabel: scene.beatLabel,
      vo: scene.vo,
      characterAction: scene.characterAction,
      cameraDirection: scene.cameraDirection,
      environment: scene.environment,
      productPlacement: scene.productPlacement,
      bRollSuggestions: scene.bRollSuggestions,
      characterName: resolvedCharacterName,
      characterDescription: resolvedCharacterDescription,
      previousSceneLastFrameImageUrl,
    });

    return {
      frameIndex: scene.sceneNumber * 2,
      sceneId: scene.sceneId,
      sceneNumber: scene.sceneNumber,
      promptKind: "first" as const,
      prompt: [basePrompt, additionalInstructions || null].filter(Boolean).join("\n\n"),
      inputImageUrl: resolvedAvatarImageUrl,
      referenceImageUrls,
      previousSceneLastFrameImageUrl,
    };
  });

  if (targetScenes.length > 0) {
    const sceneNumbersToReset = targetScenes
      .map((scene) => scene.sceneNumber)
      .filter((sceneNumber): sceneNumber is number => Number.isInteger(sceneNumber) && sceneNumber > 0);
    if (sceneNumbersToReset.length > 0) {
      try {
        const scenesToClear = await prisma.storyboardScene.findMany({
          where: {
            storyboardId: storyboard.id,
            sceneNumber: { in: sceneNumbersToReset },
          },
          select: {
            id: true,
            rawJson: true,
          },
        });
        if (scenesToClear.length > 0) {
          await prisma.$transaction(
            scenesToClear.map((scene) => {
              const raw = asObject(scene.rawJson) ?? {};
              const nextRaw = {
                ...raw,
                firstFrameImageUrl: null,
                lastFrameImageUrl: null,
                images: [],
                polled: null,
              };
              return prisma.storyboardScene.update({
                where: { id: scene.id },
                data: {
                  approved: false,
                  firstFrameImageUrl: null,
                  lastFrameImageUrl: null,
                  rawJson: nextRaw as any,
                },
              });
            }),
          );
        }
      } catch {
        // Backward compatibility for environments before approval migration is applied.
      }
    }
  }

  const runNonceFromBody = asString(body.runNonce);
  const runNonce = runNonceFromBody || (requestedSceneNumber !== null ? `scene-${requestedSceneNumber}-${Date.now()}` : "");

  const forwardedBody = {
    projectId,
    productId,
    ...(runId ? { runId } : {}),
    storyboardId: storyboard.id,
    characterId: requestedCharacter?.id ?? null,
    prompts,
    ...(additionalInstructions ? { additionalInstructions } : {}),
    force: body.force === true,
    providerId: body.providerId ? asString(body.providerId) : undefined,
    runNonce: runNonce || undefined,
  };

  const forwardedHeaders = new Headers(req.headers);
  forwardedHeaders.set("content-type", "application/json");
  forwardedHeaders.delete("content-length");

  const forwardedReq = new Request(new URL(`${req.nextUrl.pathname}/start`, req.url), {
    method: "POST",
    headers: forwardedHeaders,
    body: JSON.stringify(forwardedBody),
  });

  const startResponse = await startVideoImagesStartPost(forwardedReq);
  const startData = await startResponse.json().catch(() => ({}));
  return NextResponse.json(
    {
      ...startData,
      ...(requestedSceneNumber !== null ? { sceneNumber: requestedSceneNumber } : {}),
    },
    { status: startResponse.status },
  );
}
