import fs from "fs";
import path from "path";
import url from "url";

const __dirname = path.dirname(url.fileURLToPath(import.meta.url));
const repoRoot = path.resolve(__dirname, "..");

const JOBS_DIR = path.join(repoRoot, "app", "api", "jobs");
const OUT_DIR = path.join(repoRoot, "docs");
const OUT_MD = path.join(OUT_DIR, "billing-matrix.md");
const OUT_JSON = path.join(OUT_DIR, "billing-matrix.json");

function exists(p) {
  try {
    fs.accessSync(p);
    return true;
  } catch {
    return false;
  }
}

function walk(dir) {
  const out = [];
  if (!exists(dir)) return out;
  for (const ent of fs.readdirSync(dir, { withFileTypes: true })) {
    const full = path.join(dir, ent.name);
    if (ent.isDirectory()) out.push(...walk(full));
    else out.push(full);
  }
  return out;
}

function readText(file) {
  return fs.readFileSync(file, "utf8");
}

function rel(p) {
  return path.relative(repoRoot, p).replaceAll("\\", "/");
}

function matchAny(text, patterns) {
  return patterns.some((re) => re.test(text));
}

function extractMinPlan(text) {
  // Common shapes:
  // assertMinPlan(subscription.plan, "GROWTH")
  // assertMinPlan(plan, Plan.GROWTH)
  // assertMinPlan(..., "SCALE")
  const m =
    text.match(/assertMinPlan\([^)]*,\s*["'`]([A-Z_]+)["'`]\s*\)/) ||
    text.match(/assertMinPlan\([^)]*,\s*Plan\.([A-Z_]+)\s*\)/);
  return m ? m[1] : null;
}

function extractJobType(text) {
  // Common shapes:
  // type: "VIDEO_IMAGE_GENERATION"
  // type: JobType.VIDEO_IMAGE_GENERATION
  const m =
    text.match(/type:\s*["'`]([A-Z0-9_]+)["'`]/) ||
    text.match(/type:\s*JobType\.([A-Z0-9_]+)/);
  return m ? m[1] : null;
}

function findImports(text) {
  const lines = text.split("\n");
  const imports = [];
  for (const ln of lines) {
    const m = ln.match(/^\s*import\s+.*from\s+["']([^"']+)["']/);
    if (m) imports.push(m[1]);
  }
  return imports;
}

function analyzeRoute(file) {
  const text = readText(file);
  const imports = findImports(text);

  const flags = {
    hasPlanGate: matchAny(text, [/assertMinPlan\(/]),
    minPlan: extractMinPlan(text),
    hasReserveQuota: matchAny(text, [/reserveQuota\(/, /reserveUsage\(/]),
    hasRollbackQuota: matchAny(text, [/rollbackQuota\(/, /rollbackUsage\(/]),
    storesQuotaReservation: matchAny(text, [/quotaReservation/i, /reservationId/i]),
    hasIdempotency: matchAny(text, [/idempotencyKey/i, /idempotent/i]),
    hasRateLimit: matchAny(text, [/rateLimit/i, /rateLimiter/i]),
    hasAuthCheck: matchAny(text, [/getServerSession\(/, /requireAuth/i, /withAuth/i, /auth\(/]),
    hasOwnershipCheck: matchAny(text, [/projectId/i, /owner/i, /validateOwnership/i, /requireProject/i]),
    jobType: extractJobType(text),
    imports,
  };

  // Spend initiator heuristic: only routes that create jobs or reserve quota count toward billing completeness.
  flags.isSpendInitiator = matchAny(text, [
    /prisma\.job\.create\(/,
    /reserveQuota\(/,
    /reserveUsage\(/,
    /enqueue/i,
  ]);

  // Strong heuristic: "billing-correct" means plan gate + reserve quota + rollback quota + idempotency
  flags.billingComplete =
    flags.isSpendInitiator &&
    flags.hasPlanGate &&
    flags.hasReserveQuota &&
    (flags.hasRollbackQuota || flags.storesQuotaReservation) &&
    flags.hasIdempotency;

  // Notes for quick diagnosis
  const notes = [];
  if (!flags.isSpendInitiator) notes.push("non-spend route (excluded from billing completeness)");
  if (flags.hasPlanGate && !flags.minPlan) notes.push("plan gate present but minPlan not parsed");
  if (flags.hasPlanGate && !flags.hasReserveQuota) notes.push("plan-gated but no reserveQuota");
  if (flags.hasReserveQuota && !(flags.hasRollbackQuota || flags.storesQuotaReservation))
    notes.push("reserves quota but no rollback + no reservation persisted");
  if (!flags.hasIdempotency) notes.push("no idempotency");
  if (!flags.hasRateLimit) notes.push("no rate limit");
  if (!flags.hasAuthCheck) notes.push("no explicit auth check (may rely on middleware)");
  flags.notes = notes;

  return flags;
}

function toMd(rows) {
  const header =
    `# Billing Enforcement Matrix\n\n` +
    `Generated by \`scripts/generate_billing_matrix.mjs\`.\n\n` +
    `Legend:\n` +
    `- ✅ present\n` +
    `- ❌ missing\n\n` +
    `## Routes\n\n`;

  const cols = [
    "Route",
    "JobType",
    "MinPlan",
    "PlanGate",
    "ReserveQuota",
    "RollbackQuota",
    "PersistReservation",
    "Idempotency",
    "RateLimit",
    "Auth",
    "OwnerCheck",
    "BillingComplete",
    "Notes",
  ];

  const sep = `| ${cols.join(" | ")} |\n| ${cols.map(() => "---").join(" | ")} |\n`;

  const lines = rows.map((r) => {
    const yn = (b) => (b ? "✅" : "❌");
    const notes = r.notes && r.notes.length ? r.notes.join("; ") : "";
    return `| ${r.route} | ${r.jobType ?? ""} | ${r.minPlan ?? ""} | ${yn(r.hasPlanGate)} | ${yn(r.hasReserveQuota)} | ${yn(r.hasRollbackQuota)} | ${yn(r.storesQuotaReservation)} | ${yn(r.hasIdempotency)} | ${yn(r.hasRateLimit)} | ${yn(r.hasAuthCheck)} | ${yn(r.hasOwnershipCheck)} | ${yn(r.billingComplete)} | ${notes} |`;
  });

  return header + sep + lines.join("\n") + "\n";
}

function main() {
  if (!exists(JOBS_DIR)) {
    console.error(`Missing jobs dir: ${JOBS_DIR}`);
    process.exit(1);
  }

  const files = walk(JOBS_DIR).filter((f) => /route\.(ts|tsx|js|jsx)$/.test(f));
  const rows = files
    .map((f) => {
      const a = analyzeRoute(f);
      return { route: "/" + rel(path.dirname(f)).replace(/^app\/api/, "api"), file: rel(f), ...a };
    })
    .sort((a, b) => a.route.localeCompare(b.route));

  if (!exists(OUT_DIR)) fs.mkdirSync(OUT_DIR, { recursive: true });
  fs.writeFileSync(OUT_MD, toMd(rows), "utf8");
  fs.writeFileSync(
    OUT_JSON,
    JSON.stringify({ generatedAt: new Date().toISOString(), rows }, null, 2),
    "utf8",
  );

  const totals = {
    routes: rows.length,
    spendRoutes: rows.filter((r) => r.isSpendInitiator).length,
    billingComplete: rows.filter((r) => r.billingComplete).length,
    missingReserveQuota: rows.filter((r) => r.isSpendInitiator && r.hasPlanGate && !r.hasReserveQuota).length,
    missingIdempotency: rows.filter((r) => r.isSpendInitiator && !r.hasIdempotency).length,
  };

  console.log(`Wrote:\n- ${rel(OUT_MD)}\n- ${rel(OUT_JSON)}\n`);
  console.log(`Totals: ${JSON.stringify(totals)}`);
}

main();
